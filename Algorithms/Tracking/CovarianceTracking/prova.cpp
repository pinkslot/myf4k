#include "math_utils.h"
#include "covariance_tracked_object.h"
#include "covariance_tracker.h"
#include "generic_covariance_feature_extractor.h"
#include "gabor_feature_extractor.h"
#include <iostream>
#include <highgui.h>

using namespace std;
using namespace cv;

void test_eigen();
void test_exp_log();
void test_cov_mean();
void test_cov_dist();
void test_tracked_object_freed();
void test_rect_incr();
void test_hist();
void test_rgbxy_hist_gabor();
void test_gabor();
void test_conv_opencv();
void test_conv_manual();
void test_gabor_multichannel();
void test_create_coloredge();
void test_gabor_features();
void test_dtors();
void test_eigen3();

int main()
{
	test_cov_mean();
}

void test_eigen3()
{
	Mat m = (Mat_<double>(3,3,CV_64F) << 1,2,3,4,5,6,7,8,9);
	cout << m << endl;
	MatrixXd e = MathUtils::OpenCVToEigen(m);
	cout << e << endl;
}

void test_dtors()
{
	CovarianceTracker ct;
}

void test_gabor_features()
{
	Mat img = imread("test_gabor.png", -1);
	GaborFeatureExtractor fe;
	//fe.enable_rgb = true;
	fe.num_orientations = 2;
	fe.num_scales = 2;
	fe.min_scale = 4;
	fe.max_scale = 8;
	vector<double> features = fe.computeFeatureSet(img);
	cout << "features: ";
	for(unsigned int i=0; i<features.size(); i++)
	{
		cout << features[i] << ", ";
	}
	cout << endl << endl;
}

void test_create_coloredge()
{
	Mat img_ = Mat::zeros(50, 400, CV_8UC3);
	Mat_<Vec3b>& img = (Mat_<Vec3b>&) img_;
	// Set red stripes
	for(int i=0; i<50; i++)
	{
		for(int j=0; j<200; j++) img(i,j)[2] = 255;
	}
	// Set green stripes
	for(int i=0; i<50; i++)
	{
		for(int j=0; j<100; j++) img(i,j)[1] = 255;
		for(int j=200; j<300; j++) img(i,j)[1] = 255;
	}
	// Set blue stripes
	for(int i=0; i<50; i++)
	{
		for(int j=0; j<50; j++) img(i,j)[0] = 255;
		for(int j=100; j<150; j++) img(i,j)[0] = 255;
		for(int j=200; j<250; j++) img(i,j)[0] = 255;
		for(int j=300; j<350; j++) img(i,j)[0] = 255;
	}
	// Write image
	imwrite("img.bmp", img);
}

void test_gabor_multichannel()
{
	Mat_<Vec2d> a(2, 2, CV_64FC2);
	Mat_<Vec2d> b(2, 2, CV_64FC2);
	a(0,0) = Vec2d(1,2);
	a(0,1) = Vec2d(3,4);
	a(1,0) = Vec2d(5,6);
	a(1,1) = Vec2d(7,8);
	b(0,0) = Vec2d(9,10);
	b(0,1) = Vec2d(11,12);
	b(1,0) = Vec2d(13,14);
	b(1,1) = Vec2d(15,16);
	//cout << "a(0,0) = (" << a(0,0)[0] << "," << a(0,0)[1] << ")" << endl;
	//cout << "a(0,1) = (" << a(0,1)[0] << "," << a(0,1)[1] << ")" << endl;
	//cout << "a(1,0) = (" << a(1,0)[0] << "," << a(1,0)[1] << ")" << endl;
	//cout << "a(1,1) = (" << a(1,1)[0] << "," << a(1,1)[1] << ")" << endl;
	Mat_<Vec2d> c; multiply(a,b,c);
	cout << "c(0,0) = (" << c(0,0)[0] << "," << c(0,0)[1] << ")" << endl;
	cout << "c(0,1) = (" << c(0,1)[0] << "," << c(0,1)[1] << ")" << endl;
	cout << "c(1,0) = (" << c(1,0)[0] << "," << c(1,0)[1] << ")" << endl;
	cout << "c(1,1) = (" << c(1,1)[0] << "," << c(1,1)[1] << ")" << endl;

}

void test_conv_manual()
{
	Mat_<double> a(5, 5, CV_64F);
	a << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25;
	Mat_<double> k(3, 3, CV_64F);
	k << 1, 2, 3, 4, 5, 6, 7, 8, 9;
	cout << "a = " << endl << a << endl << endl;
	cout << "k = " << endl << k << endl << endl;
	Mat c = Mat::zeros(a.rows, a.cols, CV_64F);
	for(int n1=0; n1<a.rows; n1++)
	{
		for(int n2=0; n2<a.cols; n2++)
		{
			for(int k1=0; k1<k.rows; k1++)
			{
				for(int k2=0; k2<k.cols; k2++)
				{
					//c.at<double>(n1,n2) += 
				}
			}
		}
	}
	//filter2D(a, c, -1, k, Point(kf.cols-1, kf.rows-1));
	cout << "c = " << endl << c << endl << endl;
}

void test_conv_opencv()
{
	Mat_<double> a(5, 5, CV_64F);
	a << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25;
	Mat_<double> k(3, 3, CV_64F);
	k << 1, 2, 3, 4, 5, 6, 7, 8, 9;
	Mat kf;
	flip(k, kf, -1);
	cout << "a = " << endl << a << endl << endl;
	cout << "k = " << endl << k << endl << endl;
	cout << "kf = " << endl << kf << endl << endl;
	Mat c;
	filter2D(a, c, -1, kf, Point(-1,-1), 0, BORDER_CONSTANT);
	cout << "c = " << endl << c << endl << endl;
}

void test_gabor()
{
	/*GenericCovarianceFeatureExtractor fe;
	double lambda = 20;
	double theta = 45;
	//double psi = 0;
	double bandwidth = 1;
	double gamma = 1;
	Mat g_real = fe.createGaborFilter(lambda, theta, 0, bandwidth, gamma);
	Mat g_imag = fe.createGaborFilter(lambda, theta, M_PI/2, bandwidth, gamma);
	//cout << "g = " << endl << g << endl << endl;
	Mat img_rgb = imread("test_gabor.png");
	Mat img_gs; cvtColor(img_rgb, img_gs, CV_RGB2GRAY);
	Mat f_out = fe.applyGaborFilter(img_gs, g_real, g_imag);
	cout << "f_out.type() = " << f_out.type() << endl;
	double min_val, max_val;
	minMaxLoc(f_out, &min_val, &max_val);
	cout << "f_out min = " << min_val << ", max = " << max_val << endl;
	namedWindow("f_out");
	imshow("f_out", f_out);*/
	/*Mat f_real = fe.applyGaborFilter(img_gs, g_real);
	Mat f_imag = fe.applyGaborFilter(img_gs, g_imag);
	namedWindow("f_real");
	namedWindow("f_imag");
	namedWindow("f_sum");
	imshow("f_real", f_real);
	imshow("f_imag", f_imag);
	Mat f_real_sqr; multiply(f_real, f_real, f_real_sqr);
	Mat f_imag_sqr; multiply(f_imag, f_imag, f_imag_sqr);
	Mat f_sum_sqr = f_real_sqr + f_imag_sqr;
	Mat f_sum; sqrt(f_sum_sqr, f_sum);
	imshow("f_sum", f_sum);*/
	waitKey();
}

void test_rgbxy_hist_gabor()
{
	//Mat big_img = imread("lena.bmp");
	Mat big_img(5, 5, CV_8UC1);
	Mat_<uchar>& big_img_w = (Mat_<uchar>&) big_img;
	big_img_w << 246, 247, 249, 249, 249, 245, 247, 248, 249, 249, 177, 189, 232, 255, 255, 94, 94, 131, 171, 197, 52, 59, 92, 131, 166;
	cout << big_img << endl << endl;
	Rect rect(0, 0, 5, 5);
	Mat img = big_img(rect);
	//RGBXYHistGaborFeatureExtractor fe;
	//fe.computeFeatureSet(img, Mat::ones(img.rows, img.cols, DataType<bool>::type));
}

void test_hist()
{
	Mat img_color = imread("lena.bmp");
	Rect r(0, 0, 5, 5);
	img_color = img_color(r);
	Mat img;
	cvtColor(img_color, img, CV_RGB2GRAY);
	img.at<uchar>(0, 0) = 0;
	cout << img << endl;
	int channel = 0;
	Mat hist;
	float range[] = {0, 256};
	const float* ranges[] = {range};
	int hist_size = 256;
	calcHist(&img, 1, &channel, Mat(), hist, 1, &hist_size, ranges, true, false);
	cout << hist << endl << endl;
	Scalar norm_factor = sum(hist);
	Mat norm_hist = hist/norm_factor[0];
	cout << norm_hist << endl;
}

void test_rect_incr()
{
	Rect r(10, 20, 30, 40);
	cout << "r: (" << r.x << ", " << r.y << "), h = " << r.height << ", " << ", w = " << r.width << endl;
	//r += Size(6, 6);
	r -= Point(3,3);
	cout << "r: (" << r.x << ", " << r.y << "), h = " << r.height << ", " << ", w = " << r.width << endl;
}

void test_cov_dist()
{
	Mat a = (Mat_<double>(6, 6, CV_64F) << 4505.3971, 4896.94526, 5039.38726, -30419.98443043184, -1817589.344500121, -289070885.4977386, 4896.94526, 5425.367596, 5620.022529333333, -32243.32610276797, -1900359.990824482, -295001486.4498367, 5039.38726, 5620.022529333333, 5937.970796, -39331.07631843942, -2120254.917455417, -356318964.9939398, -30419.98443043184, -32243.32610276797, -39331.07631843942, 3514932.450742205, 76746470.98879895, 33905670930.71054, -1817589.344500121, -1900359.990824482, -2120254.917455417, 76746470.98879895, 9132418685.073015, 1003364209399.091, -289070885.4977386, -295001486.4498367, -356318964.9939398, 33905670930.71054, 1003364209399.091, 360154545349840.8);
	Mat b = (Mat_<double>(6, 6, CV_64F) << 4505.3971, 4896.94526, 5039.387259999999, -30419.9844304317, -1817589.344500117, -289070885.4977386, 4896.94526, 5425.367596, 5620.022529333332, -32243.32610276781, -1900359.990824477, -295001486.4498367, 5039.38726, 5620.022529333333, 5937.970795999999, -39331.07631843922, -2120254.917455411, -356318964.9939398, -30419.98443043184, -32243.32610276797, -39331.07631843942, 3514932.450742203, 76746470.98879889, 33905670930.71054, -1817589.344500121, -1900359.990824482, -2120254.917455417, 76746470.98879889, 9132418685.073013, 1003364209399.091, -289070885.4977386, -295001486.4498367, -356318964.9939397, 33905670930.71052, 1003364209399.09, 360154545349840.8);
	cout << b.inv()*a << endl << endl;
	double dist = MathUtils::covarianceDistance(a, b);
	cout << "distance = " << dist << endl;
}

void test_exp_log()
{
	Mat a = (Mat_<double>(3, 3, CV_64F) << 2381.949417751479, 2634.429671005917, 2725.22605443787, 2634.429671005917, 3024.055914792899, 3166.089756213018, 2725.22605443787, 3166.089756213018, 3396.964298224852);
	cout << "a = " << a << endl << endl;
	Mat log_a = MathUtils::logarithmicMap(a);
	cout << "log(a) = " << log_a << endl << endl;
	Mat exp_log_a = MathUtils::exponentialMap(log_a);
	cout << "exp(log(a)) = " << exp_log_a << endl << endl;
}

void test_tracked_object_freed()
{
	CovarianceTrackedObject t1(10,10);
	CovarianceTrackedObject t2(10,10);
	t1.stopTracking();
	t2.stopTracking();
}

void test_cov_mean()
{
	Mat *C = new Mat[10];
	//C[0] = (Mat_<double>(3, 3, CV_64F) << 2381.949417751479, 2634.429671005917, 2725.22605443787, 2634.429671005917, 3024.055914792899, 3166.089756213018, 2725.22605443787, 3166.089756213018, 3396.964298224852);
	C[0] = (Mat_<double>(8,8,CV_64F) << 2616.457952249771, 2763.979885215794, 2201.1986271809, -211.8348484848485, 36.82424242424242, 16058.71967693644, -235316.202825226, 75146021.2771292, 2763.979885215794, 2948.561457759412, 2328.138404499541, -220.5795454545455, 19.00378787878788, 17641.63841555822, -260681.170912882, 83572424.93325323, 2201.1986271809, 2328.138404499541, 1943.871099632691, -189.3068181818182, 42.52348484848485, 11309.75870471583, -187046.234072465, 53301389.53083217, -211.8348484848485, -220.5795454545455, -189.3068181818182, 40.25, 0, -1330.711495702182, 40141.26785364218, -5796543.908415965, 36.82424242424242, 19.00378787878788, 42.52348484848485, 0, 74.91666666666667, -2590.650397198899, 42865.91404433327, -17472368.7389953, 16058.71967693644, 17641.63841555822, 11309.75870471583, -1330.711495702182, -2590.650397198899, 930181.0982840845, -6029307.966196688, 5946828715.890034, -235316.202825226, -260681.170912882, -187046.234072465, 40141.26785364218, 42865.91404433327, -6029307.966196688, 218490918.562986, -41684108951.15415, 75146021.2771292, 83572424.93325323, 53301389.53083217, -5796543.908415965, -17472368.7389953, 5946828715.890034, -41684108951.15415, 40449491080571.85);
	C[1] = (Mat_<double>(8,8,CV_64F) << 3547.564650527645, 3755.879284798603, 3040.279756707045, -106.0969827586207, 49.53771551724138, 21588.34507402865, -487435.4134489914, 155996851.985045, 3755.879284798603, 4013.507941392316, 3223.820450681852, -95.99245689655173, 31.93049568965517, 23978.60673120922, -582390.1958008592, 174344447.438308, 3040.279756707045, 3223.820450681852, 2728.164841659854, -119.3480603448276, 50.68372844827586, 14193.17296389883, -493308.4550969497, 94108878.05870904, -106.0969827586207, -95.99245689655173, -119.3480603448276, 70, 0, 2345.187430253234, 14413.53686508731, 27576920.05351626, 49.53771551724138, 31.93049568965517, 50.68372844827586, 0, 85.25, -616.9308277129587, 91226.05013724392, -1902814.252626602, 21588.34507402865, 23978.60673120922, 14193.17296389883, 2345.187430253234, -616.9308277129587, 1648821.833014313, -15751482.12631257, 16059779658.58544, -487435.4134489914, -582390.1958008592, -493308.4550969497, 14413.53686508731, 91226.05013724392, -15751482.12631257, 1751081709.868269, -172436126314.0343, 155996851.9850458, 174344447.438308, 94108878.05870904, 27576920.05351626, -1902814.252626602, 16059779658.58544, -172436126314.0343, 164652817526944.4);
	C[2] = C[1];
	C[3] = C[2];
	C[4] = C[3];
	C[5] = (Mat_<double>(8,8,CV_64F) << 3557.160671819263, 3767.275639120095, 3050.133211950059, -103.9924568965517, 49.59806034482759, 21048.15311592433, -510280.6525266703, 150506148.4638103, 3767.275639120095, 4027.026307966706, 3235.208791617123, -94.10021551724138, 31.81034482758621, 23474.84616652041, -603071.9893652834, 169344865.0894444, 3050.133211950059, 3235.208791617123, 2737.762633769322, -117.3318965517241, 50.51939655172414, 13618.55353225677, -522744.8899228699, 87943759.42157188, -103.9924568965517, -94.10021551724138, -117.3318965517241, 70, 0, 2413.804184083478, 24741.98672200784, 28532077.56611516, 49.59806034482759, 31.81034482758621, 50.51939655172414, 0, 85.25, -835.3139198628543, 81651.03722663652, -4193608.48575991, 21048.15311592433, 23474.84616652041, 13618.55353225677, 2413.804184083478, -835.3139198628543, 1725435.954069889, -13696910.42731744, 16773832447.59867, -510280.6525266703, -603071.9893652834, -522744.8899228699, 24741.98672200784, 81651.03722663652, -13696910.42731744, 1814809473.98386, -154478856291.9939, 150506148.4638103, 169344865.0894444, 87943759.42157188, 28532077.56611516, -4193608.48575991, 16773832447.59867, -154478856291.9939, 170745773205747.2);
	C[6] = (Mat_<double>(8,8,CV_64F) << 3627.029210284665, 3826.406213651668, 3371.122402816039, -60.59646464646465, 23.81212121212121, 24726.48141861274, -386409.3315179979, 221420974.3494866, 3826.406213651668, 4080.652117130905, 3564.660259157229, -59.56363636363636, 6.268686868686869, 25248.21084973728, -478748.8685001248, 224634902.1561409, 3371.122402816039, 3564.660259157229, 3207.138088970513, -75.79040404040404, 43.4010101010101, 20847.52322123176, -395804.3987075565, 180373401.1704274, -60.59646464646465, -59.56363636363636, -75.79040404040404, 74.91666666666667, 0, 2261.654757268498, -40967.14657889357, 36206215.13283707, 23.81212121212121, 6.268686868686869, 43.4010101010101, 0, 90.66666666666667, 1922.338360972216, 68137.78371249874, 24259770.1133422, 24726.48141861274, 25248.21084973728, 20847.52322123176, 2261.654757268498, 1922.338360972216, 1326282.845092603, -12160746.95885103, 14761206577.98494, -386409.3315179979, -478748.8685001248, -395804.3987075565, -40967.14657889357, 68137.78371249874, -12160746.95885103, 4842526654.616661, -242999963777.0158, 221420974.3494866, 224634902.1561409, 180373401.1704274, 36206215.13283707, 24259770.1133422, 14761206577.98494, -242999963777.0158, 180681932288688.6);
	C[7] = (Mat_<double>(8,8,CV_64F) << 3161.561562101663, 3313.913167725092, 2642.624095556612, -152.5137395459976, -23.77060931899641, 26361.29229249042, -47508.13686034505, 192499362.7571083, 3313.913167725092, 3505.751984458347, 2766.659030017029, -147.6093189964158, -42.29510155316607, 27999.741438075, -128917.5015679525, 203506666.5569491, 2642.624095556612, 2766.659030017029, 2307.624296821583, -152.6547192353644, -7.415770609318995, 18286.89645933111, -140778.5308192013, 129005580.7282984, -152.5137395459976, -147.6093189964158, -152.6547192353644, 60.66666666666666, 0, 2003.509920455959, 38438.77052139161, 30728536.29556254, -23.77060931899641, -42.29510155316607, -7.415770609318995, 0, 80, 299.2919768639761, 223623.825795657, 12904729.28413914, 26361.29229249042, 27999.741438075, 18286.89645933111, 2003.509920455959, 299.2919768639761, 1353150.266290179, 18201103.21036895, 13420630661.08527, -47508.13686034505, -128917.5015679525, -140778.5308192013, 38438.77052139161, 223623.825795657, 18201103.21036895, 3308707118.422663, 231231896532.0387, 192499362.7571083, 203506666.5569491, 129005580.7282984, 30728536.29556254, 12904729.28413914, 13420630661.08527, 231231896532.0387, 142785008847766.4);
	C[8] = C[7];
	C[9] = C[8];
	Mat cov_mean = MathUtils::covarianceLieMean(C, 10, C[0], false);
	cout << "C_hat = " << cov_mean << endl << endl;
}

void test_eigen()
{
	//Mat a = (Mat_<double>(3, 3, CV_64F) << 1.096914172476449, 0.2632977979499936, 0.2010699295314793, -0.4166141308710494, 0.1362412617659544, -0.7147984566684368, 0.2805173530540095, 0.3183277475207731, 1.416958810478748);
	Mat a = Mat::eye(3,3,CV_64F);
	cout << "a = " << a << endl << endl;
	Mat eigenvalues, eigenvectors;
	cout << "gener. eigenv. (a,a) = " << MathUtils::generalizedEigen(a,a) << endl << endl;
	cout << "eigenvalues 1 = " << MathUtils::eigenAsym(a) << endl << endl;//, eigenvalues, eigenvectors);
	MathUtils::eigenAsym(a, eigenvalues, eigenvectors);
	cout << "eigenvalues 2 = " << eigenvalues << endl << endl;
	cout << "eigenvectors = " << eigenvectors << endl << endl;
	cout << "d = " << eigenvectors.inv()*a*eigenvectors << endl << endl;
}
